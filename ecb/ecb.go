// Copyright Kirk Rader 2024

package ecb

import (
	"cmp"
	"encoding/csv"
	"encoding/xml"
	"fmt"
	"io"
	"slices"
	"strconv"
	"strings"
	"time"
)

///////////////////////////////////////////////////////////////////////////////
// Public types, constants and functions
///////////////////////////////////////////////////////////////////////////////

type (

	// Exchange rate information for converting from a given currency to euros
	// as transformed from the ECB's data model to a Go struct. This same struct
	// is used in memory without regard to the original data format (XML or
	// CSV).
	//
	// Note that Timestamp is generated by the Parser functions in this package
	// while Time is copied (denormalized) from the ECB's data structures. Both
	// are included so as to enable sanity checks and similar analyses, such as
	// how frequently the data actually changes.
	//
	// See
	// https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html
	Datum struct {

		// Unix time at which the ECB data was parsed.
		Timestamp int64 `json:"timestamp,omitempty"`

		// Value of time attribute in the ECB data.
		Date string `json:"time,omitempty"`

		// ISO-4217 currency id.
		Currency string `json:"currency,omitempty"`

		// Exchange rate from the given currency to euros on the date indicated
		// in the ECB data.
		Rate float64 `json:"rate,omitempty"`
	}

	// List of ECB exchange rate data.
	Data []Datum

	// A function which parses ECB data from an io.ReadCloser.
	Parser func(io.ReadCloser) (Data, error)
)

const (

	// URL for the exchange rate CSV data for the current day.
	DAILY_CSV_URL = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref.zip"

	// URL for the exchange rate XML data for the current day.
	DAILY_XML_URL = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml"

	// URL for the historical exchange rate CSV data.
	HISTORICAL_CSV_URL = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist.zip"

	// URL for the historical exchange rate XML data.
	HISTORICAL_XML_URL = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist.xml"

	// URL for the exchange rate XML data for the last 90 days.
	NINETY_DAY_XML_URL = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist-90d.xml"
)

// Parse the ECB CSV data from the given reader.
func ParseCSV(readCloser io.Reader) (Data, error) {
	timestamp := time.Now().Unix()
	csvReader := csv.NewReader(readCloser)
	headers, err := csvReader.Read()
	if err != nil {
		return nil, err
	}
	for index, h := range headers {
		headers[index] = strings.Trim(h, " ")
	}
	dateIndex := slices.Index(headers, "Date")
	if dateIndex < 0 {
		return nil, fmt.Errorf("date header not found")
	}
	data := Data{}
	for {
		record, err := csvReader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, err
		}
		columns, err := parseRecordCSV(timestamp, dateIndex, headers, record)
		if err != nil {
			return nil, err
		}
		data = append(data, columns...)
	}
	slices.SortFunc(data, comparer)
	return data, nil
}

// Parse the ECB XML data from the given reader.
func ParseXML(reader io.Reader) (Data, error) {
	timestamp := time.Now().Unix()
	type (
		rateCube struct {
			Currency string  `xml:"currency,attr"`
			Rate     float64 `xml:"rate,attr"`
		}
		timeCube struct {
			Time      string     `xml:"time,attr"`
			RateCubes []rateCube `xml:"Cube"`
		}
		wrapperCube struct {
			TimeCube []timeCube `xml:"Cube"`
		}
		sender struct {
			Name string `xml:"name"`
		}
		document struct {
			Subject     string      `xml:"subject"`
			Sender      sender      `xml:"Sender"`
			WrapperCube wrapperCube `xml:"Cube"`
		}
	)
	decoder := xml.NewDecoder(reader)
	var doc document
	err := decoder.Decode(&doc)
	if err != nil {
		return nil, err
	}
	result := Data{}
	for _, timeCube := range doc.WrapperCube.TimeCube {
		for _, rate := range timeCube.RateCubes {
			result = append(result, Datum{
				Timestamp: timestamp,
				Date:      timeCube.Time,
				Currency:  rate.Currency,
				Rate:      rate.Rate,
			})
		}
	}
	slices.SortFunc(result, comparer)
	return result, nil
}

///////////////////////////////////////////////////////////////////////////////
// Private helper functions
///////////////////////////////////////////////////////////////////////////////

// Helper function used to sort elements of Data.
func comparer(a, b Datum) int {
	if c := cmp.Compare(a.Timestamp, b.Timestamp); c != 0 {
		return c
	}
	if c := cmp.Compare(a.Date, b.Date); c != 0 {
		return c
	}
	return cmp.Compare(a.Currency, b.Currency)
}

// ECB CSV files have inconsitent date format strings; coerce them always to use
// the same ISO 8601 format as in XML.
func normalizeTime(dateString string) (string, error) {
	_, err := time.Parse(time.DateOnly, dateString)
	if err == nil {
		return dateString, nil
	}
	t, err := time.Parse("2 Jan 2006", dateString)
	if err == nil {
		return t.Format(time.DateOnly), nil
	}
	return dateString, fmt.Errorf(`unsupported date string "%s"`, dateString)
}

// Parse one row from an ECB CSV file.
func parseRecordCSV(timestamp int64, dateIndex int, headers, record []string) (Data, error) {
	data := Data{}
	for index, header := range headers {
		if index == dateIndex {
			continue
		}
		if len(header) < 1 {
			continue
		}
		value := strings.Trim(record[index], " ")
		var datum Datum
		datum.Timestamp = timestamp
		t, err := normalizeTime(strings.Trim(record[dateIndex], " "))
		if err != nil {
			return nil, err
		}
		datum.Date = t
		f, err := strconv.ParseFloat(value, 64)
		// ignore rates that can't be parsed since many columns contain "N/A"
		if err != nil {
			continue
		}
		datum.Currency = header
		datum.Rate = f
		data = append(data, datum)
	}
	return data, nil
}
