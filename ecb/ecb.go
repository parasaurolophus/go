// Copyright Kirk Rader 2024

package ecb

import (
	"archive/zip"
	"bytes"
	"cmp"
	"encoding/csv"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"slices"
	"strconv"
	"strings"
	"time"
)

///////////////////////////////////////////////////////////////////////////////
// Public types, constants and functions
///////////////////////////////////////////////////////////////////////////////

type (

	// Exchange rate information for converting from a given currency to euros
	// as converted from the ECB's data model to a Go struct.
	//
	// Note that Timestamp is generated by the Parser functions in this package
	// while Time is copied (denormalized) from the ECB's data structures. Both
	// are included so as to enable sanity checks and similar analyses, such as
	// how frequently the data actually changes.
	//
	// See
	// https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html
	Datum struct {

		// Unix time at which the ECB data was parsed.
		Timestamp int64 `json:"timestamp,omitempty"`

		// Value of time attribute in the ECB data.
		Time string `json:"time,omitempty"`

		// ISO-4217 currency id.
		Currency string `json:"currency,omitempty"`

		// Exchange rate from the given currency to euros on the date indicated
		// in the ECB data.
		Rate float64 `json:"rate,omitempty"`
	}

	// List of ECB exchange rate data.
	Data []Datum

	// A function which parses ECB data from an io.Reader.
	Parser func(io.Reader) (Data, error)
)

const (

	// URL for the exchange rate CSV data for the current day.
	DailyCSV = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref.zip"

	// URL for the exchange rate XML data for the current day.
	DailyXML = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml"

	// URL for the historical exchange rate CSV data.
	HistoricalCSV = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist.zip"

	HistoricalXML = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist.xml"

	// URL for the exchange rate XML data for the last 90 days.
	NinetyDayXML = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist-90d.xml"
)

// Fetch ECB exchange rate data from the given URL and parse it.
func Fetch(url string, parser Parser) (Data, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return nil, fmt.Errorf("HTTP status %d", resp.StatusCode)
	}
	return parser(resp.Body)
}

// Parse the ECB CSV data from the given reader.
func ParseCSV(reader io.Reader) (Data, error) {
	timestamp := time.Now().Unix()
	// ECB CSV data is zipped and http.Response.Body() does not return an
	// io.ReaderAt so we must buffer the whole file in memory as a work-around
	// for incompatible Go library functions
	b, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	r := bytes.NewReader(b)
	z, err := zip.NewReader(r, int64(len(b)))
	if err != nil {
		return nil, err
	}
	var data Data
	for _, f := range z.File {
		contents, err := parseFileCSV(timestamp, f)
		if err != nil {
			return nil, err
		}
		data = append(data, contents...)
	}
	slices.SortFunc(data, comparer)
	return data, nil
}

// Parse the ECB XML data from the given reader.
func ParseXML(reader io.Reader) (Data, error) {
	timestamp := time.Now().Unix()
	type (
		rateCube struct {
			Currency string  `xml:"currency,attr"`
			Rate     float64 `xml:"rate,attr"`
		}
		timeCube struct {
			Time      string     `xml:"time,attr"`
			RateCubes []rateCube `xml:"Cube"`
		}
		wrapperCube struct {
			TimeCube []timeCube `xml:"Cube"`
		}
		sender struct {
			Name string `xml:"name"`
		}
		document struct {
			Subject     string      `xml:"subject"`
			Sender      sender      `xml:"Sender"`
			WrapperCube wrapperCube `xml:"Cube"`
		}
	)
	decoder := xml.NewDecoder(reader)
	var body document
	err := decoder.Decode(&body)
	if err != nil {
		return nil, err
	}
	result := Data{}
	for _, timeCube := range body.WrapperCube.TimeCube {
		for _, rate := range timeCube.RateCubes {
			result = append(result, Datum{
				Timestamp: timestamp,
				Time:      timeCube.Time,
				Currency:  rate.Currency,
				Rate:      rate.Rate,
			})
		}
	}
	slices.SortFunc(result, comparer)
	return result, nil
}

///////////////////////////////////////////////////////////////////////////////
// Private helper functions
///////////////////////////////////////////////////////////////////////////////

// Helper function used to sort ECBBdata.
func comparer(a, b Datum) int {
	if c := cmp.Compare(a.Timestamp, b.Timestamp); c != 0 {
		return c
	}
	if c := cmp.Compare(a.Time, b.Time); c != 0 {
		return c
	}
	return cmp.Compare(a.Currency, b.Currency)
}

// ECB CSV files have inconsitent date format strings; coerce them always to use
// the same ISO 8601 format used in XML.
func normalizeTime(s string) (string, error) {
	_, err := time.Parse(time.DateOnly, s)
	if err == nil {
		return s, nil
	}
	t, err := time.Parse("2 Jan 2006", s)
	if err == nil {
		return t.Format(time.DateOnly), nil
	}
	return s, fmt.Errorf(`unsupported date string "%s"`, s)
}

// Parse ECB CSV content from one file in a zip archive.
func parseFileCSV(timestamp int64, f *zip.File) (Data, error) {
	contents, err := f.Open()
	if err != nil {
		return nil, err
	}
	r := csv.NewReader(contents)
	headers, err := r.Read()
	if err != nil {
		return nil, err
	}
	dateIndex := slices.Index(headers, "Date")
	if dateIndex < 0 {
		return nil, fmt.Errorf("Date header not found")
	}
	data := Data{}
	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		columns, err := parseRecordCSV(timestamp, dateIndex, headers, record)
		if err != nil {
			return nil, err
		}
		data = append(data, columns...)
	}
	return data, nil
}

// Parse one row from an ECB CSV file.
func parseRecordCSV(timestamp int64, dateIndex int, headers, record []string) (Data, error) {
	data := Data{}
	for index, h := range headers {
		if index == dateIndex {
			continue
		}
		header := strings.Trim(h, " ")
		if len(header) < 1 {
			continue
		}
		value := strings.Trim(record[index], " ")
		var datum Datum
		datum.Timestamp = timestamp
		t, err := normalizeTime(strings.Trim(record[dateIndex], " "))
		if err != nil {
			return nil, err
		}
		datum.Time = t
		f, err := strconv.ParseFloat(value, 64)
		// ignore rates that can't be parsed since many columns contain "N/A"
		if err != nil {
			continue
		}
		datum.Currency = header
		datum.Rate = f
		data = append(data, datum)
	}
	return data, nil
}
