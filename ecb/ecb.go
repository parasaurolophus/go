// Copyright Kirk Rader 2024

package ecb

import (
	"cmp"
	"encoding/xml"
	"io"
	"net/http"
	"slices"
	"strings"
	"time"
)

type (

	// Exchange rate information for converting from a given currency to euros
	// as converted from the ECB's data model to a Go struct.
	//
	// Note that Timestamp is generated by the Parse(io.Reader) function in this
	// package while Time is copied (denormalized) from the ECB's XML data
	// structure. Both are included so as to enable sanity checks and analyses,
	// such as how frequently the data actually changes.
	//
	// See
	// https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html
	Datum struct {

		// Unix time at which the ECB data was parsed.
		Timestamp int64 `json:"timestamp,omitempty"`

		// Value of time attribute in the ECB data.
		Time string `json:"time,omitempty"`

		// ISO-4217 currency id.
		Currency string `json:"currency,omitempty"`

		// Exchange rate from the given currency to euros on the date indicated
		// in the ECB data.
		Rate float64 `json:"rate,omitempty"`
	}

	// List of ECB exchange rate data.
	Data []Datum
)

const (

	// URL for the historical exchange rate data for the last ninety days.
	NinetyDayURL = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist-90d.xml"

	// URL for the exchange rate for the current day.
	DailyURL = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml"
)

// Fetch the ECB XML data from the given URL and parse it.
func Fetch(url string) (Data, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	return Parse(resp.Body)
}

// Parse the ECB XML data from the given reader.
func Parse(reader io.Reader) (Data, error) {
	timestamp := time.Now().Unix()
	type (
		rateCube struct {
			Currency string  `xml:"currency,attr"`
			Rate     float64 `xml:"rate,attr"`
		}
		timeCube struct {
			Time      string     `xml:"time,attr"`
			RateCubes []rateCube `xml:"Cube"`
		}
		wrapperCube struct {
			TimeCube []timeCube `xml:"Cube"`
		}
		sender struct {
			Name string `xml:"name"`
		}
		document struct {
			Subject     string      `xml:"subject"`
			Sender      sender      `xml:"Sender"`
			WrapperCube wrapperCube `xml:"Cube"`
		}
	)
	decoder := xml.NewDecoder(reader)
	var body document
	err := decoder.Decode(&body)
	if err != nil {
		return nil, err
	}
	result := Data{}
	for _, timeCube := range body.WrapperCube.TimeCube {
		for _, rate := range timeCube.RateCubes {
			result = append(result, Datum{
				Timestamp: timestamp,
				Time:      timeCube.Time,
				Currency:  rate.Currency,
				Rate:      rate.Rate,
			})
		}
	}
	slices.SortFunc(result, comparer)
	return result, nil
}

// Helper function used to sort ECBBdata.
func comparer(a, b Datum) int {
	if c := cmp.Compare(a.Timestamp, b.Timestamp); c != 0 {
		return c
	}
	if c := cmp.Compare(a.Time, b.Time); c != 0 {
		return strings.Compare(a.Time, b.Time)
	}
	return cmp.Compare(a.Currency, b.Currency)
}
