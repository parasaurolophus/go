// Copyright Kirk Rader 2024

package ecb

import (
	"cmp"
	"encoding/csv"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"slices"
	"strconv"
	"strings"
	"time"
)

type (

	// Exchange rate information for converting from a given currency to euros
	// as converted from the ECB's data model to a Go struct.
	//
	// Note that Timestamp is generated by the Parse(io.Reader) function in this
	// package while Time is copied (denormalized) from the ECB's XML data
	// structure. Both are included so as to enable sanity checks and analyses,
	// such as how frequently the data actually changes.
	//
	// See
	// https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html
	Datum struct {

		// Unix time at which the ECB data was parsed.
		Timestamp int64 `json:"timestamp,omitempty"`

		// Value of time attribute in the ECB data.
		Time string `json:"time,omitempty"`

		// ISO-4217 currency id.
		Currency string `json:"currency,omitempty"`

		// Exchange rate from the given currency to euros on the date indicated
		// in the ECB data.
		Rate float64 `json:"rate,omitempty"`
	}

	// List of ECB exchange rate data.
	Data []Datum

	Parser func(io.Reader) (Data, error)
)

const (

	// URL for the exchange rate CSV data for the current day.
	DailyCSV = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref.zip"

	// URL for the exchange rate XML data for the current day.
	DailyXML = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml"

	// URL for the historical exchange rate CSV data.
	HistoricalCSV = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist.zip"

	HistoricalXML = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist.xml"

	// URL for the exchange rate XML data for the last 90 days.
	NinetyDayXML = "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-hist-90d.xml"
)

// Fetch ECB exchange rate data from the given URL and parse it.
func Fetch(url string, parser Parser) (Data, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return nil, fmt.Errorf("HTTP status %d", resp.StatusCode)
	}
	return parser(resp.Body)
}

// Parse the ECB CSV data from the given reader.
func ParseCSV(reader io.Reader) (Data, error) {
	r := csv.NewReader(reader)
	headers, err := r.Read()
	if err != nil {
		return nil, err
	}
	var data Data
	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		var datum Datum
		for index, h := range headers {
			header := strings.Trim(h, " ")
			value := strings.Trim(record[index], " ")
			if header == "Date" {
				// TODO: convert value to ISO 8601
				datum.Time = value
			}
			f, err := strconv.ParseFloat(value, 64)
			// ignore rates that can't be parsed since many columns contain "N/A"
			if err != nil {
				continue
			}
			datum.Currency = header
			datum.Rate = f
			data = append(data, datum)
		}
	}
	slices.SortFunc(data, comparer)
	return data, nil
}

// Parse the ECB XML data from the given reader.
func ParseXML(reader io.Reader) (Data, error) {
	timestamp := time.Now().Unix()
	type (
		rateCube struct {
			Currency string  `xml:"currency,attr"`
			Rate     float64 `xml:"rate,attr"`
		}
		timeCube struct {
			Time      string     `xml:"time,attr"`
			RateCubes []rateCube `xml:"Cube"`
		}
		wrapperCube struct {
			TimeCube []timeCube `xml:"Cube"`
		}
		sender struct {
			Name string `xml:"name"`
		}
		document struct {
			Subject     string      `xml:"subject"`
			Sender      sender      `xml:"Sender"`
			WrapperCube wrapperCube `xml:"Cube"`
		}
	)
	decoder := xml.NewDecoder(reader)
	var body document
	err := decoder.Decode(&body)
	if err != nil {
		return nil, err
	}
	result := Data{}
	for _, timeCube := range body.WrapperCube.TimeCube {
		for _, rate := range timeCube.RateCubes {
			result = append(result, Datum{
				Timestamp: timestamp,
				Time:      timeCube.Time,
				Currency:  rate.Currency,
				Rate:      rate.Rate,
			})
		}
	}
	slices.SortFunc(result, comparer)
	return result, nil
}

// Helper function used to sort ECBBdata.
func comparer(a, b Datum) int {
	if c := cmp.Compare(a.Timestamp, b.Timestamp); c != 0 {
		return c
	}
	if c := cmp.Compare(a.Time, b.Time); c != 0 {
		return strings.Compare(a.Time, b.Time)
	}
	return cmp.Compare(a.Currency, b.Currency)
}
